<html>

<head>
    <title>DataViz</title>
    <style type="text/css">
        #container {
            display: flex;
            border: 1px solid #ccc; /* Frame around the container */
            border-radius: 5px;
            overflow: hidden;
        }

        #controls {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #ccc; /* Vertical frame between controls and graph */
        }

        #viz {
            flex: 3;
            width: 900px;
            height: 700px;
            border-left: 1px solid #ccc; /* Vertical frame between graph and controls */
        }
    </style>
    <script src="https://rawgit.com/neo4j-contrib/neovis.js/master/dist/neovis.js"></script>
</head>

<script type="text/javascript">
    // Not working
    // import { sendPostRequest } from "/static/js/core.js";
    // The difficulty level of the problem of importing a js file is non-trivial for this project to be solved
    // Copy paste from core.js begins
    async function sendPostRequest(url, body, headers = {'Content-Type': 'application/x-www-form-urlencoded'}) {
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });
        const data = await response.json();
        if (response.ok) {
            return data;
        } else {
            throw new Error(data.detail || 'Unknown error occurred');
        }
    }
    // Copy paste from core.js end
    var viz;
    const databaseName = "got";

    function draw() {
        var config = {
            containerId: "viz",
            neo4j: {
                serverUrl: "bolt://localhost:7687",
                serverUser: "neo4j",
                serverPassword: "12345678",
            },
            serverDatabase: databaseName,
            labels: {
                Character: {
                    label: "name",
                    value: "pagerank",
                    group: "temp_type" // Use the updated property to assign colors
                }
            },
            relationships: {
                INTERACTS: {
                    value: "weight"
                }
            },
            initialCypher: "MATCH p = (n)-[r]->(m) RETURN p LIMIT 100"
        };

        viz = new NeoVis.default(config);
        viz.render();
    }

    async function filterNodes() {
        var labelName = document.getElementById("labelName").value;
        var propertyName = document.getElementById("propertyName").value;
        var propertyValue = document.getElementById("propertyValue").value;
        var parseAsNumber = document.getElementById("parseAsNumber").checked;

        var query = "MATCH (n)";
        if (labelName !== "") {
            query += `:${labelName}`;
        }

        if (parseAsNumber) {
            query += ` WHERE toFloat(n.${propertyName}) = ${propertyValue}`;
        } else {
            query += ` WHERE n.${propertyName} = "${propertyValue}"`;
        }
        query += " RETURN id(n)";
        const body = `database_name=${encodeURIComponent(databaseName)}&query=${encodeURIComponent(query)}`;
        const url = 'http://localhost:8000/execute-query/';

        try {
            const result = await sendPostRequest(url, body);
            if (result && result.length > 0) {
                const nodeIds = result.map(item => item['id(n)']);  // Extract node IDs from the result
                document.getElementById('nodeIds').value = nodeIds.join(", ");
                visualizeNodes([], nodeIds);  // Pass the IDs to visualizeNodes function
            } else {
                console.log('No nodes found or query error');
            }
        } catch (error) {
            console.error('Error executing query:', error.message);
        }
    }

    // function visualizeNodes(nodeIdsS, nodeIdsR) {
    // // Convert arrays of IDs to comma-separated strings for Cypher query inclusion
    //     const idListR = nodeIdsR.join(",");
    //     const idListS = nodeIdsS.join(",");

    //     // Construct the Cypher query to visualize nodes
    //     const vizQuery = `
    //         // Match all nodes involved in the relationships
    //         MATCH (n)
    //         WHERE id(n) IN [${idListR}]
    //         WITH n
    //         MATCH p = (n)-[r]->(m)
    //         // Set temp_is_r to 1 if n is in nodeIdsR, else 0 (for m not in nodeIdsR)
    //         SET n.temp_is_r = 1,
    //             m.temp_is_r = CASE WHEN id(m) IN [${idListR}] THEN 1 ELSE 0 END
    //         // Set temp_is_s to 1 if in nodeIdsS, else 0 for both n and m
    //         SET n.temp_is_s = CASE WHEN id(n) IN [${idListS}] THEN 1 ELSE 0 END,
    //             m.temp_is_s = CASE WHEN id(m) IN [${idListS}] THEN 1 ELSE 0 END
    //             SET n.temp_type = CASE 
    //             WHEN n.temp_is_r = 1 AND n.temp_is_s = 1 THEN 1
    //             WHEN n.temp_is_r = 0 AND n.temp_is_s = 1 THEN 2
    //             WHEN n.temp_is_r = 1 AND n.temp_is_s = 0 THEN 3
    //             ELSE 4 END,
    //             m.temp_type = CASE 
    //             WHEN m.temp_is_r = 1 AND m.temp_is_s = 1 THEN 1
    //             WHEN m.temp_is_r = 0 AND m.temp_is_s = 1 THEN 2
    //             WHEN m.temp_is_r = 1 AND m.temp_is_s = 0 THEN 3
    //             ELSE 4 END
    //         RETURN p
    //     `;

    //     // Execute the query to visualize the graph with updated properties
    //     viz.renderWithCypher(vizQuery);
    // }

    async function visualizeNodes(nodeIdsS, nodeIdsR) {
        const idListR = nodeIdsR.join(",");
        const idListS = nodeIdsS.join(",");

        const setAttributesQuery = `
            MATCH (n)
            WHERE id(n) IN [${idListR}]
            WITH n
            MATCH p = (n)-[r]->(m)
            SET m.temp_is_r = 0
            SET n.temp_is_r = 1
            SET n.temp_is_s = CASE WHEN id(n) IN [${idListS}] THEN 1 ELSE 0 END,
                m.temp_is_s = CASE WHEN id(m) IN [${idListS}] THEN 1 ELSE 0 END
        `;

        const body = `database_name=${encodeURIComponent(databaseName)}&query=${encodeURIComponent(setAttributesQuery)}`;
        const url = 'http://localhost:8000/execute-query/';

        try {
            // Execute setting attributes using the server-side API
            await sendPostRequest(url, body);
            // Once attributes are set, call the visualization function
            doVisualizeNodes(nodeIdsR);
        } catch (error) {
            console.error('Error setting attributes:', error.message);
        }
    } // TODO: reuse it in this way?

    // Assuming temp_is_r and temp_is_s is set for nodeIdsR,
    // this function sets temp_type for all nodes in N+(R) for visualization
    function doVisualizeNodes(nodeIdsR) {
        const idListR = nodeIdsR.join(",");

        const vizQuery = `
            MATCH (n)
            WHERE id(n) IN [${idListR}]
            WITH n
            MATCH p = (n)-[r]->(m)
                SET n.temp_type = CASE 
                WHEN n.temp_is_r = 1 AND n.temp_is_s = 1 THEN 1
                WHEN n.temp_is_r = 0 AND n.temp_is_s = 1 THEN 2
                WHEN n.temp_is_r = 1 AND n.temp_is_s = 0 THEN 3
                ELSE 4 END,
                m.temp_type = CASE 
                WHEN m.temp_is_r = 1 AND m.temp_is_s = 1 THEN 1
                WHEN m.temp_is_r = 0 AND m.temp_is_s = 1 THEN 2
                WHEN m.temp_is_r = 1 AND m.temp_is_s = 0 THEN 3
                ELSE 4 END
            RETURN p
        `;

        // Execute the query to visualize the graph with updated properties
        viz.renderWithCypher(vizQuery);
    }

</script>

<body onload="draw()">
    <div id="container">
        <div id="controls">
            <label for="labelName">Label (optional):</label>
            <input type="text" id="labelName" name="labelName"><br><br>
            <label for="propertyName">Property Name:</label>
            <input type="text" id="propertyName" name="propertyName" value="community"><br><br>
            <label for="propertyValue">Property Value:</label>
            <input type="text" id="propertyValue" name="propertyValue" value="1">
            <input type="checkbox" id="parseAsNumber" name="parseAsNumber" checked>
            <label for="parseAsNumber">As number</label><br><br>
            <button onclick="filterNodes()">Filter Nodes</button>
            <label for="nodeIds">id(n):</label>
            <textarea id="nodeIds" rows="4" cols="50" readonly></textarea>
        </div>
        <div id="viz"></div>
    </div>
</body>

</html>
