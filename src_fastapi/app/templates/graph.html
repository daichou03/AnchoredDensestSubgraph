<html>

<head>
    <title>DataViz</title>
    <style type="text/css">
        #container {
            display: flex;
            border: 1px solid #ccc; /* Frame around the container */
            border-radius: 5px;
            overflow: hidden;
        }

        #controls {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #ccc; /* Vertical frame between controls and graph */
        }

        #viz {
            flex: 3;
            width: 900px;
            height: 700px;
            border-left: 1px solid #ccc; /* Vertical frame between graph and controls */
        }
    </style>
    <script src="https://rawgit.com/neo4j-contrib/neovis.js/master/dist/neovis.js"></script>
</head>

<script type="text/javascript">
    // Not working
    // import { sendPostRequest } from "/static/js/core.js";
    // The difficulty level of the problem of importing a js file is non-trivial for this project to be solved
    // Copy paste from core.js begins
    async function sendPostRequest(url, body, headers = {'Content-Type': 'application/x-www-form-urlencoded'}) {
        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: body
        });
        const data = await response.json();
        if (response.ok) {
            return data;
        } else {
            throw new Error(data.detail || 'Unknown error occurred');
        }
    }
    // Copy paste from core.js end
    var viz;

    function getDatabaseName() {
        return databaseName = document.getElementById("databaseName").value;
    }

    function draw() {
        var config = {
            containerId: "viz",
            neo4j: {
                serverUrl: "bolt://localhost:7687",
                serverUser: "neo4j",
                serverPassword: "12345678",
            },
            serverDatabase: getDatabaseName(),
            labels: {
                Character: {
                    label: "name",
                    value: "pagerank",
                    group: "temp_type" // Use the updated property to assign colors
                }
            },
            relationships: {
                INTERACTS: {
                    value: "weight"
                }
            },
            initialCypher: "MATCH p = (n)-[r]->(m) RETURN p LIMIT 100"
        };

        viz = new NeoVis.default(config);
        viz.render();
    }

    async function handleFilterNodes() {
        var labelName = document.getElementById("labelName").value;
        var propertyName = document.getElementById("propertyName").value;
        var propertyValue = document.getElementById("propertyValue").value;
        var parseAsNumber = document.getElementById("parseAsNumber").checked;

        var query = "MATCH (n)";
        if (labelName !== "") {
            query += `:${labelName}`;
        }

        if (parseAsNumber) {
            query += ` WHERE toFloat(n.${propertyName}) = ${propertyValue}`;
        } else {
            query += ` WHERE n.${propertyName} = "${propertyValue}"`;
        }
        query += " RETURN n.julia_id";
        const body = `database_name=${encodeURIComponent(getDatabaseName())}&query=${encodeURIComponent(query)}`;
        const url = 'http://localhost:8000/execute-query/';

        try {
            const result = await sendPostRequest(url, body);
            if (result && result.length > 0) {
                const nodeIdsR = result.map(item => item['n.julia_id']);  // Extract node IDs from the result
                document.getElementById('nodeIdsR').value = nodeIdsR.join(", ");
                visualizeNodes([], nodeIdsR);  // Pass the IDs to visualizeNodes function
            } else {
                console.log('No nodes found or query error');
            }
        } catch (error) {
            console.error('Error executing query:', error.message);
        }
    }

    async function visualizeNodes(nodeIdsS, nodeIdsR) {
        const idListR = nodeIdsR.join(",");
        const idListS = nodeIdsS.join(",");

        const setAttributesQuery = `
            MATCH (n)
            WHERE n.julia_id IN [${idListR}]
            WITH n
            MATCH p = (n)-[r]->(m)
            SET m.temp_is_r = 0
            SET n.temp_is_r = 1
            SET n.temp_is_s = CASE WHEN n.julia_id IN [${idListS}] THEN 1 ELSE 0 END,
                m.temp_is_s = CASE WHEN m.julia_id IN [${idListS}] THEN 1 ELSE 0 END
        `;

        const body = `database_name=${encodeURIComponent(getDatabaseName())}&query=${encodeURIComponent(setAttributesQuery)}`;
        const url = 'http://localhost:8000/execute-query/';

        try {
            // Execute setting attributes using the server-side API
            await sendPostRequest(url, body);
            // Once attributes are set, call the visualization function
            doVisualizeNodes(nodeIdsR);
        } catch (error) {
            console.error('Error setting attributes:', error.message);
        }
    } // TODO: reuse it in this way?

    // Assuming temp_is_r and temp_is_s is set for nodeIdsR,
    // this function sets temp_type for all nodes in N+(R) for visualization
    function doVisualizeNodes(nodeIdsR) {
        const idListR = nodeIdsR.join(",");

        const vizQuery = `
            MATCH (n)
            WHERE n.julia_id IN [${idListR}]
            WITH n
            MATCH p = (n)-[r]->(m)
                SET n.temp_type = CASE 
                WHEN n.temp_is_r = 1 AND n.temp_is_s = 1 THEN 1
                WHEN n.temp_is_r = 0 AND n.temp_is_s = 1 THEN 2
                WHEN n.temp_is_r = 1 AND n.temp_is_s = 0 THEN 3
                ELSE 4 END,
                m.temp_type = CASE 
                WHEN m.temp_is_r = 1 AND m.temp_is_s = 1 THEN 1
                WHEN m.temp_is_r = 0 AND m.temp_is_s = 1 THEN 2
                WHEN m.temp_is_r = 1 AND m.temp_is_s = 0 THEN 3
                ELSE 4 END
            RETURN p
        `;

        // Execute the query to visualize the graph with updated properties
        viz.renderWithCypher(vizQuery);
    }

    // Performs a local community detection algorithm that takes R, returns S and visualize.
    // It only uses information from neo4j without calling Julia server (core algorithm).
    // TODO: refactor - duplications.
    async function handleDummyLocalCommunityDetection() {
        var idsStringR = document.getElementById('nodeIdsR').value;
        var nodeIdsR = idsStringR.split(", ").map(Number);
        
        const idListR = nodeIdsR.join(",");
        const lcdQuery = `
            MATCH (n)
            WHERE n.julia_id IN [${idListR}]
            WITH n
            MATCH (n)-[r]->(m)
            WITH collect(n) + collect(m) AS all_nodes
            UNWIND all_nodes AS node
            WITH node
            WHERE node.pagerank > 0 AND -1/log10(node.pagerank) > rand()
            RETURN DISTINCT node.julia_id
        `;

        const body = `database_name=${encodeURIComponent(getDatabaseName())}&query=${encodeURIComponent(lcdQuery)}`;
        const url = 'http://localhost:8000/execute-query/';
        try {
            const result = await sendPostRequest(url, body);
            if (result && result.length > 0) {
                const nodeIdsS = result.map(item => item['node.julia_id']);  // Extract node IDs from the result
                document.getElementById('nodeIdsS').value = nodeIdsS.join(", ");
                visualizeNodes(nodeIdsS, nodeIdsR);  // Pass the IDs to visualizeNodes function
            } else {
                console.log('No nodes found or query error');
            }
        } catch (error) {
            console.error('Error executing query:', error.message);
        }
    }

    async function handleGadsLocalCommunityDetection() {
        ensureJuliaLoadSyncGraph();
        var idsStringR = document.getElementById('nodeIdsR').value;
        var nodeIdsR = idsStringR.split(", ").map(Number);
        var weightMap = [2, 2, 0, 0, 0, 0, -1];  // TODO
        const urlGADS = 'http://localhost:8000/solve-gads/';  // Endpoint URL

        try {
            const payload = JSON.stringify({R: nodeIdsR, weight_map: weightMap});
            const gadsResponse = await fetch(urlGADS, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: payload
            });
            if (!gadsResponse.ok) {
                throw new Error('Failed to fetch from solve-gads endpoint: ', gadsResponse);
            }

            const nodeIdsS = await gadsResponse.json();  // Parse JSON response to get node IDs
            const idListS = nodeIdsS.join(",");  // Convert array of node IDs to a string for Cypher query

            if (idListS && idListS.length > 0) {
                document.getElementById('nodeIdsS').value = nodeIdsS.join(", ");
                visualizeNodes(nodeIdsS, nodeIdsR);  // Pass the IDs to visualizeNodes function
            } else {
                console.log('No nodes found or query error');
            }
        } catch (error) {
            console.error('Error in community detection or setting attributes:', error.message);
        }
    }

    async function ensureJuliaLoadSyncGraph() {
        const databaseName = getDatabaseName();
        const loadGraphUrl = 'http://localhost:8000/load-graph-sync/';

        try {
            // Load graph before performing community detection
            const loadGraphResponse = await fetch(loadGraphUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ dataname: databaseName })
            });

            if (!loadGraphResponse.ok) {
                throw new Error('Failed to sync graph for julia: ', databaseName);
            }
        } catch (error) {
            console.error('Error in community detection or setting attributes:', error.message);
        }
    }

</script>

<body onload="draw()">
    <div id="container">
        <div id="controls">
            <label for="databaseName">Database Name:</label>
            <input type="text" id="databaseName" name="databaseName" value="got"><hr>
            <label for="labelName">Label (optional):</label>
            <input type="text" id="labelName" name="labelName"><br><br>
            <label for="propertyName">Property Name:</label>
            <input type="text" id="propertyName" name="propertyName" value="community"><br><br>
            <label for="propertyValue">Property Value:</label>
            <input type="text" id="propertyValue" name="propertyValue" value="1">
            <input type="checkbox" id="parseAsNumber" name="parseAsNumber" checked>
            <label for="parseAsNumber">As number</label><br><br>
            <button onclick="handleFilterNodes()">Filter Nodes</button><br><br>
            <label for="nodeIdsR">julia_id of R:</label>
            <textarea id="nodeIdsR" rows="4" cols="50" readonly></textarea><br><br>
            <label for="nodeIdsS">julia_id of S:</label>
            <textarea id="nodeIdsS" rows="4" cols="50" readonly></textarea><br><br>
            <button onclick="handleDummyLocalCommunityDetection()">Dummy LCD</button><br><br>
            <label for="omega12">ω<sub>12</sub></label>
            <input type="text" id="omega12" size=5 name="omega12" value="2">
            <label for="omega24">ω<sub>24</sub></label>
            <input type="text" id="omega24" size=5 name="omega24" value="-1">
            <button onclick="handleGadsLocalCommunityDetection()">GADS</button><br><br>
        </div>
        <div id="viz"></div>
    </div>
</body>

</html>
